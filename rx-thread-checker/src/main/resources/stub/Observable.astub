import org.checkerframework.checker.guieffect.qual.*;
import com.ubercab.rxthreadchecker.qual.*;

/* READ ME BEFORE MODIFYING THIS FILE                                                                                                                                                    This stub file is used to provide annotations to a Checker Framework typechecker.  While it
 looks like Java, the syntax has a number of key differences from Java.  What's more, most
 syntax errors will not throw an error - they will silently fail and you will have no idea
 what's going on.  Read the _entire_ annotation stub chapter of the Checker Framework manual
 at https://checkerframework.org/manual/#stub-using before proceeding.
*/

package io.reactivex;

class Observable<T> implements ObservableSource<T> {
    Observable();
//    static <T> Observable<T> amb(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> ambArray(ObservableSource<? extends T>[] arg0);
//    static int bufferSize();
//    static <T, R> Observable<R> combineLatest(Function<? super Object[],? extends R> arg0, int arg1, ObservableSource<? extends T>[] arg2);
//    static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
//    static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1, int arg2);
//    static <T, R> Observable<R> combineLatest(ObservableSource<? extends T>[] arg0, Function<? super Object[],? extends R> arg1);
//    static <T, R> Observable<R> combineLatest(ObservableSource<? extends T>[] arg0, Function<? super Object[],? extends R> arg1, int arg2);
    static <T1, T2, R> @PolyThread Observable<R> combineLatest(@PolyThread ObservableSource<? extends T1> arg0, @PolyThread ObservableSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2);
    static <T1, T2, T3, R> @PolyThread Observable<R> combineLatest(@PolyThread ObservableSource<? extends T1> arg0, @PolyThread ObservableSource<? extends T2> arg1, @PolyThread ObservableSource<? extends T3> arg2, Function3<? super T1,? super T2,? super T3,? extends R> arg3);
    static <T1, T2, T3, T4, R> @PolyThread  Observable<R> combineLatest(@PolyThread ObservableSource<? extends T1> arg0, @PolyThread ObservableSource<? extends T2> arg1, @PolyThread ObservableSource<? extends T3> arg2, @PolyThread ObservableSource<? extends T4> arg3, Function4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
    static <T1, T2, T3, T4, T5, R> @PolyThread Observable<R> combineLatest(@PolyThread ObservableSource<? extends T1> arg0, @PolyThread ObservableSource<? extends T2> arg1, @PolyThread ObservableSource<? extends T3> arg2, @PolyThread ObservableSource<? extends T4> arg3, @PolyThread ObservableSource<? extends T5> arg4, Function5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
//    static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, Function6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
//    static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> combineLatest(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, Function7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
//    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> combineLatest(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, ObservableSource<? extends T8> arg7, Function8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
//    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> combineLatest(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, ObservableSource<? extends T8> arg7, ObservableSource<? extends T9> arg8, Function9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
//    static <T, R> Observable<R> combineLatestDelayError(ObservableSource<? extends T>[] arg0, Function<? super Object[],? extends R> arg1);
//    static <T, R> Observable<R> combineLatestDelayError(Function<? super Object[],? extends R> arg0, int arg1, ObservableSource<? extends T>[] arg2);
//    static <T, R> Observable<R> combineLatestDelayError(ObservableSource<? extends T>[] arg0, Function<? super Object[],? extends R> arg1, int arg2);
//    static <T, R> Observable<R> combineLatestDelayError(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
//    static <T, R> Observable<R> combineLatestDelayError(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1, int arg2);
//    static <T> Observable<T> concat(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static <T> Observable<T> concat(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1);
//    static <T> Observable<T> concat(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, ObservableSource<? extends T> arg2);
//    static <T> Observable<T> concat(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, ObservableSource<? extends T> arg2, ObservableSource<? extends T> arg3);
//    static <T> Observable<T> concatArray(ObservableSource<? extends T>[] arg0);
//    static <T> Observable<T> concatArrayDelayError(ObservableSource<? extends T>[] arg0);
//    static <T> Observable<T> concatArrayEager(ObservableSource<? extends T>[] arg0);
//    static <T> Observable<T> concatArrayEager(int arg0, int arg1, ObservableSource<? extends T>[] arg2);
//    static <T> Observable<T> concatDelayError(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1, boolean arg2);
//    static <T> Observable<T> concatEager(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concatEager(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1, int arg2);
//    static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> concatEager(Iterable<? extends ObservableSource<? extends T>> arg0, int arg1, int arg2);
//    static <T> Observable<T> create(ObservableOnSubscribe<T> arg0);
    static <T> @AnyThread Observable<T> defer(Callable<? extends ObservableSource<? extends T>> arg0);
    static <T> @AnyThread Observable<T> empty();
//    static <T> Observable<T> error(Callable<? extends Throwable> arg0);
//    static <T> Observable<T> error(Throwable arg0);
//    static <T> Observable<T> fromArray(T[] arg0);
//    static <T> Observable<T> fromCallable(Callable<? extends T> arg0);
//    static <T> Observable<T> fromFuture(Future<? extends T> arg0);
//    static <T> Observable<T> fromFuture(Future<? extends T> arg0, long arg1, TimeUnit arg2);
//    static <T> Observable<T> fromFuture(Future<? extends T> arg0, long arg1, TimeUnit arg2, Scheduler arg3);
//    static <T> Observable<T> fromFuture(Future<? extends T> arg0, Scheduler arg1);
//    static <T> Observable<T> fromIterable(Iterable<? extends T> arg0);
//    static <T> Observable<T> fromPublisher(Publisher<? extends T> arg0);
//    static <T> Observable<T> generate(Consumer<Emitter<T>> arg0);
//    static <T, S> Observable<T> generate(Callable<S> arg0, BiConsumer<S,Emitter<T>> arg1);
//    static <T, S> Observable<T> generate(Callable<S> arg0, BiConsumer<S,Emitter<T>> arg1, Consumer<? super S> arg2);
//    static <T, S> Observable<T> generate(Callable<S> arg0, BiFunction<S,Emitter<T>,S> arg1);
//    static <T, S> Observable<T> generate(Callable<S> arg0, BiFunction<S,Emitter<T>,S> arg1, Consumer<? super S> arg2);
//    static Observable<Long> interval(long arg0, long arg1, TimeUnit arg2);
//    static Observable<Long> interval(long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    static @AnyThread Observable<Long> interval(long arg0, TimeUnit arg1);
//    static Observable<Long> interval(long arg0, TimeUnit arg1, Scheduler arg2);
    static @AnyThread Observable<Long> intervalRange(long arg0, long arg1, long arg2, long arg3, TimeUnit arg4);
    static @PolyThread Observable<Long> intervalRange(long arg0, long arg1, long arg2, long arg3, TimeUnit arg4, @PolyThread Scheduler arg5);
    static <T> @AnyThread Observable<T> just(T arg0);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7, T arg8);
    static <T> @AnyThread Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7, T arg8, T arg9);
//    static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> arg0, int arg1, int arg2);
//    static <T> Observable<T> mergeArray(int arg0, int arg1, ObservableSource<? extends T>[] arg2);
//    static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> merge(Iterable<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static <T> Observable<T> merge(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> merge(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1);
    static <T> @PolyThread Observable<T> merge(@PolyThread ObservableSource<? extends T> arg0, @PolyThread ObservableSource<? extends T> arg1);
    static <T> @PolyThread Observable<T> merge(@PolyThread ObservableSource<? extends T> arg0, @PolyThread ObservableSource<? extends T> arg1, @PolyThread ObservableSource<? extends T> arg2);
    static <T> @PolyThread Observable<T> merge(@PolyThread ObservableSource<? extends T> arg0, @PolyThread ObservableSource<? extends T> arg1, @PolyThread ObservableSource<? extends T> arg2, @PolyThread ObservableSource<? extends T> arg3);
//    static <T> Observable<T> mergeArray(ObservableSource<? extends T>[] arg0);
//    static <T> Observable<T> mergeDelayError(Iterable<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> mergeDelayError(Iterable<? extends ObservableSource<? extends T>> arg0, int arg1, int arg2);
//    static <T> Observable<T> mergeArrayDelayError(int arg0, int arg1, ObservableSource<? extends T>[] arg2);
//    static <T> Observable<T> mergeDelayError(Iterable<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static <T> Observable<T> mergeDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> mergeDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1);
//    static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, ObservableSource<? extends T> arg2);
//    static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, ObservableSource<? extends T> arg2, ObservableSource<? extends T> arg3);
//    static <T> Observable<T> mergeArrayDelayError(ObservableSource<? extends T>[] arg0);
//    static <T> Observable<T> never();
//    static Observable<Integer> range(int arg0, int arg1);
//    static Observable<Long> rangeLong(long arg0, long arg1);
//    static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1);
//    static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, BiPredicate<? super T,? super T> arg2);
//    static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, BiPredicate<? super T,? super T> arg2, int arg3);
//    static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> arg0, ObservableSource<? extends T> arg1, int arg2);
//    static <T> Observable<T> switchOnNext(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static <T> Observable<T> switchOnNext(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> switchOnNextDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0);
//    static <T> Observable<T> switchOnNextDelayError(ObservableSource<? extends ObservableSource<? extends T>> arg0, int arg1);
//    static Observable<Long> timer(long arg0, TimeUnit arg1);
//    static Observable<Long> timer(long arg0, TimeUnit arg1, Scheduler arg2);
//    static <T> Observable<T> unsafeCreate(ObservableSource<T> arg0);
//    static <T, D> Observable<T> using(Callable<? extends D> arg0, Function<? super D,? extends ObservableSource<? extends T>> arg1, Consumer<? super D> arg2);
//    static <T, D> Observable<T> using(Callable<? extends D> arg0, Function<? super D,? extends ObservableSource<? extends T>> arg1, Consumer<? super D> arg2, boolean arg3);
//    static <T> Observable<T> wrap(ObservableSource<T> arg0);
//    static <T, R> Observable<R> zip(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
//    static <T, R> Observable<R> zip(ObservableSource<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
//    static <T1, T2, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2);
//    static <T1, T2, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2, boolean arg3);
//    static <T1, T2, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2, boolean arg3, int arg4);
//    static <T1, T2, T3, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, Function3<? super T1,? super T2,? super T3,? extends R> arg3);
//    static <T1, T2, T3, T4, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, Function4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
//    static <T1, T2, T3, T4, T5, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, Function5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
//    static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, Function6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
//    static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, Function7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
//    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, ObservableSource<? extends T8> arg7, Function8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
//    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> zip(ObservableSource<? extends T1> arg0, ObservableSource<? extends T2> arg1, ObservableSource<? extends T3> arg2, ObservableSource<? extends T4> arg3, ObservableSource<? extends T5> arg4, ObservableSource<? extends T6> arg5, ObservableSource<? extends T7> arg6, ObservableSource<? extends T8> arg7, ObservableSource<? extends T9> arg8, Function9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
//    static <T, R> Observable<R> zipArray(Function<? super Object[],? extends R> arg0, boolean arg1, int arg2, ObservableSource<? extends T>[] arg3);
//    static <T, R> Observable<R> zipIterable(Iterable<? extends ObservableSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1, boolean arg2, int arg3);
//    Single<Boolean> all(Predicate<? super T> arg0);
//    Observable<T> ambWith(ObservableSource<? extends T> arg0);
//    Single<Boolean> any(Predicate<? super T> arg0);
    <R> @PolyThread R as(@PolyThread Observable<T> this, ObservableConverter<T, ? extends R> converter);
//    T blockingFirst();
//    T blockingFirst(T arg0);
//    void blockingForEach(Consumer<? super T> arg0);
//    Iterable<T> blockingIterable();
//    Iterable<T> blockingIterable(int arg0);
//    T blockingLast();
//    T blockingLast(T arg0);
//    Iterable<T> blockingLatest();
//    Iterable<T> blockingMostRecent(T arg0);
//    Iterable<T> blockingNext();
//    T blockingSingle();
//    T blockingSingle(T arg0);
//    Future<T> toFuture();
//    void blockingSubscribe();
//    void blockingSubscribe(Consumer<? super T> arg0);
//    void blockingSubscribe(Consumer<? super T> arg0, Consumer<? super Throwable> arg1);
//    void blockingSubscribe(Consumer<? super T> arg0, Consumer<? super Throwable> arg1, Action arg2);
//    void blockingSubscribe(Observer<? super T> arg0);
//    Observable<List<T>> buffer(int arg0);
//    Observable<List<T>> buffer(int arg0, int arg1);
//    <U> Observable<U> buffer(int arg0, int arg1, Callable<U> arg2);
//    <U> Observable<U> buffer(int arg0, Callable<U> arg1);
//    Observable<List<T>> buffer(long arg0, long arg1, TimeUnit arg2);
//    Observable<List<T>> buffer(long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
//    <U> Observable<U> buffer(long arg0, long arg1, TimeUnit arg2, Scheduler arg3, Callable<U> arg4);
//    Observable<List<T>> buffer(long arg0, TimeUnit arg1);
//    Observable<List<T>> buffer(long arg0, TimeUnit arg1, int arg2);
//    Observable<List<T>> buffer(long arg0, TimeUnit arg1, Scheduler arg2, int arg3);
//    <U> Observable<U> buffer(long arg0, TimeUnit arg1, Scheduler arg2, int arg3, Callable<U> arg4, boolean arg5);
//    Observable<List<T>> buffer(long arg0, TimeUnit arg1, Scheduler arg2);
//    <TOpening, TClosing> Observable<List<T>> buffer(ObservableSource<? extends TOpening> arg0, Function<? super TOpening,? extends ObservableSource<? extends TClosing>> arg1);
//    <TOpening, TClosing, U> Observable<U> buffer(ObservableSource<? extends TOpening> arg0, Function<? super TOpening,? extends ObservableSource<? extends TClosing>> arg1, Callable<U> arg2);
//    <B> Observable<List<T>> buffer(ObservableSource<B> arg0);
//    <B> Observable<List<T>> buffer(ObservableSource<B> arg0, int arg1);
//    <B, U> Observable<U> buffer(ObservableSource<B> arg0, Callable<U> arg1);
//    <B> Observable<List<T>> buffer(Callable<? extends ObservableSource<B>> arg0);
//    <B, U> Observable<U> buffer(Callable<? extends ObservableSource<B>> arg0, Callable<U> arg1);
//    Observable<T> cache();
//    Observable<T> cacheWithInitialCapacity(int arg0);
      <U> @PolyThread Observable<U> cast(@PolyThread Observable<T> this, Class<U> arg0);
//    <U> Single<U> collect(Callable<? extends U> arg0, BiConsumer<? super U,? super T> arg1);
//    <U> Single<U> collectInto(U arg0, BiConsumer<? super U,? super T> arg1);
    <R> @PolyThread Observable<R> compose(@PolyThread Observable<T> this, ObservableTransformer<? super T,? extends R> arg0);
//    <R> Observable<R> concatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0);
//    <R> Observable<R> concatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1);
//    <R> Observable<R> concatMapDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0);
//    <R> Observable<R> concatMapDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1, boolean arg2);
//    <R> Observable<R> concatMapEager(Function<? super T,? extends ObservableSource<? extends R>> arg0);
//    <R> Observable<R> concatMapEager(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1, int arg2);
//    <R> Observable<R> concatMapEagerDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0, boolean arg1);
//    <R> Observable<R> concatMapEagerDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1, int arg2, boolean arg3);
//    <U> Observable<U> concatMapIterable(Function<? super T,? extends Iterable<? extends U>> arg0);
//    <U> Observable<U> concatMapIterable(Function<? super T,? extends Iterable<? extends U>> arg0, int arg1);
//    Observable<T> concatWith(ObservableSource<? extends T> arg0);
//    Single<Boolean> contains(Object arg0);
//    Single<Long> count();
//    <U> Observable<T> debounce(Function<? super T,? extends ObservableSource<U>> arg0);
//    Observable<T> debounce(long arg0, TimeUnit arg1);
    @PolyThread Observable<T> debounce(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
//    Observable<T> defaultIfEmpty(T arg0);
//    <U> Observable<T> delay(Function<? super T,? extends ObservableSource<U>> arg0);
    @CompThread Observable<T> delay(long arg0, TimeUnit arg1);
    @CompThread Observable<T> delay(long arg0, TimeUnit arg1, boolean arg2);
    @PolyThread Observable<T> delay(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
    @PolyThread Observable<T> delay(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2, boolean arg3);
//    <U, V> Observable<T> delay(ObservableSource<U> arg0, Function<? super T,? extends ObservableSource<V>> arg1);
    @PolyThread <U> Observable<T> delaySubscription(@PolyThread Observable<T> this, ObservableSource<U> arg0);
    @PolyThread Observable<T> delaySubscription(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> delaySubscription(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
//    <T2> Observable<T2> dematerialize();
//    Observable<T> distinct();
//    <K> Observable<T> distinct(Function<? super T,K> arg0);
//    <K> Observable<T> distinct(Function<? super T,K> arg0, Callable<? extends Collection<? super K>> arg1);
    @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this);
    <K> @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this, Function<? super T,K> arg0);
    @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this, BiPredicate<? super T,? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doAfterNext(@PolyThread Observable<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doAfterTerminate(@PolyThread Observable<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doFinally(@PolyThread Observable<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnDispose(@PolyThread Observable<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnComplete(@PolyThread Observable<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @UI Consumer<? super Notification<T>> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @UI Observer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnError(@PolyThread Observable<T> this, @UI Consumer<? super Throwable> arg0);
    @SubscribeEffects({0,1}) @PolyThread Observable<T> doOnLifecycle(@PolyThread Observable<T> this, @PolyUI Consumer<? super Disposable> arg0, @UI Action arg1);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnNext(@PolyThread Observable<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnSubscribe(@PolyThread Observable<T> this, @UI Consumer<? super Disposable> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnTerminate(@PolyThread Observable<T> this, @UI Action arg0);
//    Maybe<T> elementAt(long arg0);
//    Single<T> elementAt(long arg0, T arg1);
//    Single<T> elementAtOrError(long arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> filter(@PolyThread Observable<T> this, @PolyUI Predicate<? super T> arg0);
    @PolyThread Maybe<T> firstElement(@PolyThread Observable<T> this);
    @PolyThread Single<T> first(@PolyThread Observable<T> this, T arg0);
    @PolyThread Single<T> firstOrError(@PolyThread Observable<T> this);
    @SubscribeEffects({0}) <R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, @PolyUI Function<? super T,? extends ObservableSource<? extends R>> arg0);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, boolean arg1);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, boolean arg1, int arg2);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, boolean arg1, int arg2, int arg3);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, Function<? super Throwable,? extends ObservableSource<? extends R>> arg1, Callable<? extends ObservableSource<? extends R>> arg2);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, Function<Throwable,? extends ObservableSource<? extends R>> arg1, Callable<? extends ObservableSource<? extends R>> arg2, int arg3);
//    <R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1);
//    <U, R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1);
//    <U, R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1, boolean arg2);
//    <U, R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1, boolean arg2, int arg3);
//    <U, R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1, boolean arg2, int arg3, int arg4);
//    <U, R> Observable<R> flatMap(Function<? super T,? extends ObservableSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1, int arg2);
//    Completable flatMapCompletable(Function<? super T,? extends CompletableSource> arg0);
//    Completable flatMapCompletable(Function<? super T,? extends CompletableSource> arg0, boolean arg1);
//    <U> Observable<U> flatMapIterable(Function<? super T,? extends Iterable<? extends U>> arg0);
//    <U, V> Observable<V> flatMapIterable(Function<? super T,? extends Iterable<? extends U>> arg0, BiFunction<? super T,? super U,? extends V> arg1);
//    <R> Observable<R> flatMapMaybe(Function<? super T,? extends MaybeSource<? extends R>> arg0);
//    <R> Observable<R> flatMapMaybe(Function<? super T,? extends MaybeSource<? extends R>> arg0, boolean arg1);
//    <R> Observable<R> flatMapSingle(Function<? super T,? extends SingleSource<? extends R>> arg0);
//    <R> Observable<R> flatMapSingle(Function<? super T,? extends SingleSource<? extends R>> arg0, boolean arg1);
//    Disposable forEach(Consumer<? super T> arg0);
//    Disposable forEachWhile(Predicate<? super T> arg0);
//    Disposable forEachWhile(Predicate<? super T> arg0, Consumer<? super Throwable> arg1);
//    Disposable forEachWhile(Predicate<? super T> arg0, Consumer<? super Throwable> arg1, Action arg2);
//    <K> Observable<GroupedObservable<K,T>> groupBy(Function<? super T,? extends K> arg0);
//    <K> Observable<GroupedObservable<K,T>> groupBy(Function<? super T,? extends K> arg0, boolean arg1);
//    <K, V> Observable<GroupedObservable<K,V>> groupBy(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1);
//    <K, V> Observable<GroupedObservable<K,V>> groupBy(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1, boolean arg2);
//    <K, V> Observable<GroupedObservable<K,V>> groupBy(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1, boolean arg2, int arg3);
//    <TRight, TLeftEnd, TRightEnd, R> Observable<R> groupJoin(ObservableSource<? extends TRight> arg0, Function<? super T,? extends ObservableSource<TLeftEnd>> arg1, Function<? super TRight,? extends ObservableSource<TRightEnd>> arg2, BiFunction<? super T,? super Observable<TRight>,? extends R> arg3);
    @PolyThread Observable<T> hide(@PolyThread Observable<T> this);
//    Completable ignoreElements();
//    Single<Boolean> isEmpty();
//    <TRight, TLeftEnd, TRightEnd, R> Observable<R> join(ObservableSource<? extends TRight> arg0, Function<? super T,? extends ObservableSource<TLeftEnd>> arg1, Function<? super TRight,? extends ObservableSource<TRightEnd>> arg2, BiFunction<? super T,? super TRight,? extends R> arg3);
//    Maybe<T> lastElement();
//    Single<T> last(T arg0);
//    Single<T> lastOrError();
//    <R> Observable<R> lift(ObservableOperator<? extends R,? super T> arg0);
    @SubscribeEffects({0}) <R> @PolyThread Observable<R> map(@PolyThread Observable<T> this, @PolyUI Function<? super T,? extends R> arg0);
//    Observable<Notification<T>> materialize();
//    Observable<T> mergeWith(ObservableSource<? extends T> arg0);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0, boolean arg1);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0, boolean arg1, int arg2);
//    <U> Observable<U> ofType(Class<U> arg0);
//    Observable<T> onErrorResumeNext(Function<? super Throwable,? extends ObservableSource<? extends T>> arg0);
//    Observable<T> onErrorResumeNext(ObservableSource<? extends T> arg0);
//    Observable<T> onErrorReturn(Function<? super Throwable,? extends T> arg0);
//    Observable<T> onErrorReturnItem(T arg0);
//    Observable<T> onExceptionResumeNext(ObservableSource<? extends T> arg0);
//    Observable<T> onTerminateDetach();
//    ConnectableObservable<T> publish();
//    <R> Observable<R> publish(Function<? super Observable<T>,? extends ObservableSource<R>> arg0);
//    Maybe<T> reduce(BiFunction<T,T,T> arg0);
//    <R> Single<R> reduce(R arg0, BiFunction<R,? super T,R> arg1);
//    <R> Single<R> reduceWith(Callable<R> arg0, BiFunction<R,? super T,R> arg1);
//    Observable<T> repeat();
//    Observable<T> repeat(long arg0);
//    Observable<T> repeatUntil(BooleanSupplier arg0);
    @PolyThread Observable<T> repeatWhen(@PolyThread Observable<T> this, Function<? super Observable<Object>,? extends ObservableSource<?>> arg0);
//    ConnectableObservable<T> replay();
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, int arg1);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, int arg1, long arg2, TimeUnit arg3);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, int arg1, long arg2, TimeUnit arg3, Scheduler arg4);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, int arg1, Scheduler arg2);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, long arg1, TimeUnit arg2);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, long arg1, TimeUnit arg2, Scheduler arg3);
//    <R> Observable<R> replay(Function<? super Observable<T>,? extends ObservableSource<R>> arg0, Scheduler arg1);
      @PolyThread ConnectableObservable<T> replay(@PolyThread Observable this, int arg0);
//    ConnectableObservable<T> replay(int arg0, long arg1, TimeUnit arg2);
//    ConnectableObservable<T> replay(int arg0, long arg1, TimeUnit arg2, Scheduler arg3);
//    ConnectableObservable<T> replay(int arg0, Scheduler arg1);
//    ConnectableObservable<T> replay(long arg0, TimeUnit arg1);
//    ConnectableObservable<T> replay(long arg0, TimeUnit arg1, Scheduler arg2);
//    ConnectableObservable<T> replay(Scheduler arg0);
//    Observable<T> retry();
//    Observable<T> retry(BiPredicate<? super Integer,? super Throwable> arg0);
//    Observable<T> retry(long arg0);
//    Observable<T> retry(long arg0, Predicate<? super Throwable> arg1);
//    Observable<T> retry(Predicate<? super Throwable> arg0);
//    Observable<T> retryUntil(BooleanSupplier arg0);
//    Observable<T> retryWhen(Function<? super Observable<Throwable>,? extends ObservableSource<?>> arg0);
//    void safeSubscribe(Observer<? super T> arg0);
//    Observable<T> sample(long arg0, TimeUnit arg1);
//    Observable<T> sample(long arg0, TimeUnit arg1, boolean arg2);
//    Observable<T> sample(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<T> sample(long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3);
//    <U> Observable<T> sample(ObservableSource<U> arg0);
//    <U> Observable<T> sample(ObservableSource<U> arg0, boolean arg1);
//    Observable<T> scan(BiFunction<T,T,T> arg0);
//    <R> Observable<R> scan(R arg0, BiFunction<R,? super T,R> arg1);
//    <R> Observable<R> scanWith(Callable<R> arg0, BiFunction<R,? super T,R> arg1);
//    Observable<T> serialize();
//    Observable<T> share();
//    Maybe<T> singleElement();
//    Single<T> single(T arg0);
    @PolyThread Single<T> singleOrError(@PolyThread Observable<T> this);
//    Observable<T> skip(long arg0);
//    Observable<T> skip(long arg0, TimeUnit arg1);
//    Observable<T> skip(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<T> skipLast(int arg0);
//    Observable<T> skipLast(long arg0, TimeUnit arg1);
//    Observable<T> skipLast(long arg0, TimeUnit arg1, boolean arg2);
//    Observable<T> skipLast(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<T> skipLast(long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3);
//    Observable<T> skipLast(long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3, int arg4);
//    <U> Observable<T> skipUntil(ObservableSource<U> arg0);
//    Observable<T> skipWhile(Predicate<? super T> arg0);
//    Observable<T> sorted();
    @PolyThread Observable<T> sorted(@PolyThread Observable<T> this, Comparator<? super T> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, Iterable<? extends T> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, ObservableSource<? extends T> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0);
//    Observable<T> startWithArray(T[] arg0);
//    Disposable subscribe();
    @SubscribeEffects({0}) Disposable subscribe(@UI Consumer<? super T> arg0);
    @SubscribeEffects({0,1}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1);
    @SubscribeEffects({0,1,2}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1, @UI Action arg2);
    @SubscribeEffects({0,1,2,3}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1, @UI Action arg2, @UI Consumer<? super Disposable> arg3);
    @SubscribeEffects({0}) void subscribe(@UI Observer arg0);
//    protected void subscribeActual(Observer<? super T> arg0);
    @SubscribeEffects({0}) <E> E subscribeWith(@UI E arg0);
//    Observable<T> subscribeOn(Scheduler arg0);
//    Observable<T> switchIfEmpty(ObservableSource<? extends T> arg0);
    <R> @AnyThread Observable<R> switchMap(@AnyThread Observable<T> this, @PolyUI Function<? super T,? extends ObservableSource<? extends R>> arg0);
    <R> @AnyThread Observable<R> switchMap(@AnyThread Observable<T> this, @PolyUI Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1);
    <R> @AnyThread Observable<R> switchMapSingle(@AnyThread Observable<T> this, Function<? super T,? extends SingleSource<? extends R>> arg0);
//    <R> Observable<R> switchMapSingleDelayError(Function<? super T,? extends SingleSource<? extends R>> arg0);
//    <R> Observable<R> switchMapDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0);
//    <R> Observable<R> switchMapDelayError(Function<? super T,? extends ObservableSource<? extends R>> arg0, int arg1);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, long arg0);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, long arg1, TimeUnit arg2);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, long arg1, TimeUnit arg2, Scheduler arg3, boolean arg4, int arg5);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, boolean arg2);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3, int arg4);
    <U> @PolyThread Observable<T> takeUntil(@PolyThread Observable<T> this, ObservableSource<U> arg0);
    @PolyThread Observable<T> takeUntil(@PolyThread Observable<T> this, Predicate<? super T> arg0);
    @PolyThread Observable<T> takeWhile(@PolyThread Observable<T> this, Predicate<? super T> arg0);
//    Observable<T> throttleFirst(long arg0, TimeUnit arg1);
//    Observable<T> throttleFirst(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<T> throttleLast(long arg0, TimeUnit arg1);
//    Observable<T> throttleLast(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<T> throttleWithTimeout(long arg0, TimeUnit arg1);
//    Observable<T> throttleWithTimeout(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<Timed<T>> timeInterval();
//    Observable<Timed<T>> timeInterval(Scheduler arg0);
//    Observable<Timed<T>> timeInterval(TimeUnit arg0);
//    Observable<Timed<T>> timeInterval(TimeUnit arg0, Scheduler arg1);
//    <V> Observable<T> timeout(Function<? super T,? extends ObservableSource<V>> arg0);
//    <V> Observable<T> timeout(Function<? super T,? extends ObservableSource<V>> arg0, ObservableSource<? extends T> arg1);
//    Observable<T> timeout(long arg0, TimeUnit arg1);
//    Observable<T> timeout(long arg0, TimeUnit arg1, ObservableSource<? extends T> arg2);
//    Observable<T> timeout(long arg0, TimeUnit arg1, Scheduler arg2, ObservableSource<? extends T> arg3);
//    Observable<T> timeout(long arg0, TimeUnit arg1, Scheduler arg2);
//    <U, V> Observable<T> timeout(ObservableSource<U> arg0, Function<? super T,? extends ObservableSource<V>> arg1);
//    <U, V> Observable<T> timeout(ObservableSource<U> arg0, Function<? super T,? extends ObservableSource<V>> arg1, ObservableSource<? extends T> arg2);
//    Observable<Timed<T>> timestamp();
//    Observable<Timed<T>> timestamp(Scheduler arg0);
//    Observable<Timed<T>> timestamp(TimeUnit arg0);
//    Observable<Timed<T>> timestamp(TimeUnit arg0, Scheduler arg1);
    <R> @PolyThread R to(@PolyThread Observable<T> this, Function<? super Observable<T>,R> arg0);
//    Single<List<T>> toList();
//    Single<List<T>> toList(int arg0);
//    <U> Single<U> toList(Callable<U> arg0);
//    <K> Single<Map<K,T>> toMap(Function<? super T,? extends K> arg0);
//    <K, V> Single<Map<K,V>> toMap(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1);
//    <K, V> Single<Map<K,V>> toMap(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1, Callable<? extends Map<K,V>> arg2);
//    <K> Single<Map<K,Collection<T>>> toMultimap(Function<? super T,? extends K> arg0);
//    <K, V> Single<Map<K,Collection<V>>> toMultimap(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1);
//    <K, V> Single<Map<K,Collection<V>>> toMultimap(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1, Callable<? extends Map<K,Collection<V>>> arg2, Function<? super K,? extends Collection<? super V>> arg3);
//    <K, V> Single<Map<K,Collection<V>>> toMultimap(Function<? super T,? extends K> arg0, Function<? super T,? extends V> arg1, Callable<Map<K,Collection<V>>> arg2);
//    Flowable<T> toFlowable(BackpressureStrategy arg0);
//    Single<List<T>> toSortedList();
//    Single<List<T>> toSortedList(Comparator<? super T> arg0);
//    Single<List<T>> toSortedList(Comparator<? super T> arg0, int arg1);
//    Single<List<T>> toSortedList(int arg0);
//    Observable<T> unsubscribeOn(Scheduler arg0);
//    Observable<Observable<T>> window(long arg0);
//    Observable<Observable<T>> window(long arg0, long arg1);
//    Observable<Observable<T>> window(long arg0, long arg1, int arg2);
//    Observable<Observable<T>> window(long arg0, long arg1, TimeUnit arg2);
//    Observable<Observable<T>> window(long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
//    Observable<Observable<T>> window(long arg0, long arg1, TimeUnit arg2, Scheduler arg3, int arg4);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, long arg2);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, long arg2, boolean arg3);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, Scheduler arg2);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, Scheduler arg2, long arg3);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, Scheduler arg2, long arg3, boolean arg4);
//    Observable<Observable<T>> window(long arg0, TimeUnit arg1, Scheduler arg2, long arg3, boolean arg4, int arg5);
//    <B> Observable<Observable<T>> window(ObservableSource<B> arg0);
//    <B> Observable<Observable<T>> window(ObservableSource<B> arg0, int arg1);
//    <U, V> Observable<Observable<T>> window(ObservableSource<U> arg0, Function<? super U,? extends ObservableSource<V>> arg1);
//    <U, V> Observable<Observable<T>> window(ObservableSource<U> arg0, Function<? super U,? extends ObservableSource<V>> arg1, int arg2);
//    <B> Observable<Observable<T>> window(Callable<? extends ObservableSource<B>> arg0);
//    <B> Observable<Observable<T>> window(Callable<? extends ObservableSource<B>> arg0, int arg1);
    <U, R> @PolyThread Observable<R> withLatestFrom(@PolyThread Observable<T> this, ObservableSource<? extends U> arg0, BiFunction<? super T,? super U,? extends R> arg1);
//    <T1, T2, R> Observable<R> withLatestFrom(ObservableSource<T1> arg0, ObservableSource<T2> arg1, Function3<? super T,? super T1,? super T2,R> arg2);
//    <T1, T2, T3, R> Observable<R> withLatestFrom(ObservableSource<T1> arg0, ObservableSource<T2> arg1, ObservableSource<T3> arg2, Function4<? super T,? super T1,? super T2,? super T3,R> arg3);
//    <T1, T2, T3, T4, R> Observable<R> withLatestFrom(ObservableSource<T1> arg0, ObservableSource<T2> arg1, ObservableSource<T3> arg2, ObservableSource<T4> arg3, Function5<? super T,? super T1,? super T2,? super T3,? super T4,R> arg4);
//    <R> Observable<R> withLatestFrom(ObservableSource<?>[] arg0, Function<? super Object[],R> arg1);
//    <R> Observable<R> withLatestFrom(Iterable<? extends ObservableSource<?>> arg0, Function<? super Object[],R> arg1);
//    <U, R> Observable<R> zipWith(Iterable<U> arg0, BiFunction<? super T,? super U,? extends R> arg1);
//    <U, R> Observable<R> zipWith(ObservableSource<? extends U> arg0, BiFunction<? super T,? super U,? extends R> arg1);
//    <U, R> Observable<R> zipWith(ObservableSource<? extends U> arg0, BiFunction<? super T,? super U,? extends R> arg1, boolean arg2);
//    <U, R> Observable<R> zipWith(ObservableSource<? extends U> arg0, BiFunction<? super T,? super U,? extends R> arg1, boolean arg2, int arg3);
//    TestObserver<T> test();
//    TestObserver<T> test(boolean arg0);
}
package rx;

class Observable<T> {
    //    protected Observable(OnSubscribe<T> arg0);
    //    static <T> Observable<T> create(OnSubscribe<T> arg0);
    //    static <T> Observable<T> create(Action1<Emitter<T>> arg0, BackpressureMode arg1);
    //    static <T> Observable<T> unsafeCreate(OnSubscribe<T> arg0);
    //    static <S, T> Observable<T> create(SyncOnSubscribe<S,T> arg0);
    //    static <S, T> Observable<T> create(AsyncOnSubscribe<S,T> arg0);
    //    <R> Observable<R> lift(Operator<? extends R,? super T> arg0);
    <R> @PolyThread Observable<R> compose(@PolyThread Observable<T> this, Transformer<? super T,? extends R> arg0);
    //    <R> R to(Func1<? super Observable<T>,R> arg0);
    //    Single<T> toSingle();
    //    Completable toCompletable();
    //    static <T> Observable<T> amb(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> amb(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    static <T1, T2, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Func2<? super T1,? super T2,? extends R> arg2);
    //    static <T1, T2, T3, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Func3<? super T1,? super T2,? super T3,? extends R> arg3);
    //    static <T1, T2, T3, T4, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Func4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
    //    static <T1, T2, T3, T4, T5, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Func5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
    //    static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Func6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
    //    static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Func7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Observable<? extends T8> arg7, Func8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> combineLatest(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Observable<? extends T8> arg7, Observable<? extends T9> arg8, Func9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
    //    static <T, R> Observable<R> combineLatest(List<? extends Observable<? extends T>> arg0, FuncN<? extends R> arg1);
    //    static <T, R> Observable<R> combineLatest(Iterable<? extends Observable<? extends T>> arg0, FuncN<? extends R> arg1);
    //    static <T, R> Observable<R> combineLatestDelayError(Iterable<? extends Observable<? extends T>> arg0, FuncN<? extends R> arg1);
    //    static <T> Observable<T> concat(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concat(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> concat(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    static <T> Observable<T> concatDelayError(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concatDelayError(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> concatDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    static <T> Observable<T> defer(Func0<Observable<T>> arg0);
    //    static <T> Observable<T> empty();
    //    static <T> Observable<T> error(Throwable arg0);
    //    static <T> Observable<T> from(Future<? extends T> arg0);
    //    static <T> Observable<T> from(Future<? extends T> arg0, long arg1, TimeUnit arg2);
    //    static <T> Observable<T> from(Future<? extends T> arg0, Scheduler arg1);
    //    static <T> Observable<T> from(Iterable<? extends T> arg0);
    //    static <T> Observable<T> from(T[] arg0);
    //    static <T> Observable<T> fromCallable(Callable<? extends T> arg0);
    //    static Observable<Long> interval(long arg0, TimeUnit arg1);
    //    static Observable<Long> interval(long arg0, TimeUnit arg1, Scheduler arg2);
    //    static Observable<Long> interval(long arg0, long arg1, TimeUnit arg2);
    //    static Observable<Long> interval(long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    //    static <T> Observable<T> just(T arg0);
    //    static <T> Observable<T> just(T arg0, T arg1);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7, T arg8);
    //    static <T> Observable<T> just(T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7, T arg8, T arg9);
    //    static <T> Observable<T> merge(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> merge(Iterable<? extends Observable<? extends T>> arg0, int arg1);
    //    static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> arg0, int arg1);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> merge(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    static <T> Observable<T> merge(Observable<? extends T>[] arg0);
    //    static <T> Observable<T> merge(Observable<? extends T>[] arg0, int arg1);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends Observable<? extends T>> arg0, int arg1);
    //    static <T> Observable<T> mergeDelayError(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> mergeDelayError(Iterable<? extends Observable<? extends T>> arg0, int arg1);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> mergeDelayError(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    Observable<Observable<T>> nest();
    //    static <T> Observable<T> never();
    //    static Observable<Integer> range(int arg0, int arg1);
    //    static Observable<Integer> range(int arg0, int arg1, Scheduler arg2);
    //    static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> arg0, Observable<? extends T> arg1, Func2<? super T,? super T,Boolean> arg2);
    //    static <T> Observable<T> switchOnNext(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> switchOnNextDelayError(Observable<? extends Observable<? extends T>> arg0);
    //    static Observable<Long> timer(long arg0, long arg1, TimeUnit arg2);
    //    static Observable<Long> timer(long arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    //    static Observable<Long> timer(long arg0, TimeUnit arg1);
    //    static Observable<Long> timer(long arg0, TimeUnit arg1, Scheduler arg2);
    //    static <T, Resource> Observable<T> using(Func0<Resource> arg0, Func1<? super Resource,? extends Observable<? extends T>> arg1, Action1<? super Resource> arg2);
    //    static <T, Resource> Observable<T> using(Func0<Resource> arg0, Func1<? super Resource,? extends Observable<? extends T>> arg1, Action1<? super Resource> arg2, boolean arg3);
    //    static <R> Observable<R> zip(Iterable<? extends Observable<?>> arg0, FuncN<? extends R> arg1);
    //    static <R> Observable<R> zip(Observable<?>[] arg0, FuncN<? extends R> arg1);
    //    static <R> Observable<R> zip(Observable<? extends Observable<?>> arg0, FuncN<? extends R> arg1);
    //    static <T1, T2, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Func2<? super T1,? super T2,? extends R> arg2);
    //    static <T1, T2, T3, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Func3<? super T1,? super T2,? super T3,? extends R> arg3);
    //    static <T1, T2, T3, T4, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Func4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
    //    static <T1, T2, T3, T4, T5, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Func5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
    //    static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Func6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
    //    static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Func7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Observable<? extends T8> arg7, Func8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> zip(Observable<? extends T1> arg0, Observable<? extends T2> arg1, Observable<? extends T3> arg2, Observable<? extends T4> arg3, Observable<? extends T5> arg4, Observable<? extends T6> arg5, Observable<? extends T7> arg6, Observable<? extends T8> arg7, Observable<? extends T9> arg8, Func9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
    @PolyThread Observable<Boolean> all(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> ambWith(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    @PolyThread Observable<T> asObservable(@PolyThread Observable<T> this);
    //    <TClosing> Observable<List<T>> buffer(Func0<? extends Observable<? extends TClosing>> arg0);
    @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, int arg0, int arg1);
    @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, long arg0, long arg1, TimeUnit arg2);
    @PolyThread Observable<List<T>> buffer(long arg0, long arg1, TimeUnit arg2, @PolyThread Scheduler arg3);
    @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, int arg2);
    @PolyThread Observable<List<T>> buffer(long arg0, TimeUnit arg1, int arg2, @PolyThread Scheduler arg3);
    @PolyThread Observable<List<T>> buffer(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
    //    <TOpening, TClosing> Observable<List<T>> buffer(Observable<? extends TOpening> arg0, Func1<? super TOpening,? extends Observable<? extends TClosing>> arg1);
    <B> @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, Observable<B> arg0);
    <B> @PolyThread Observable<List<T>> buffer(@PolyThread Observable<T> this, Observable<B> arg0, int arg1);
    @PolyThread Observable<T> cache(@PolyThread Observable<T> this);
    @PolyThread Observable<T> cache(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> cacheWithInitialCapacity(@PolyThread Observable<T> this, int arg0);
    <R> @PolyThread Observable<R> cast(@PolyThread Observable<T> this, Class<R> arg0);
    <R> @PolyThread Observable<R> collect(@PolyThread Observable<T> this, Func0<R> arg0, Action2<R,? super T> arg1);
    <R> @PolyThread Observable<R> concatMap(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    <R> @PolyThread Observable<R> concatMapDelayError(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    <R> @PolyThread Observable<R> concatMapIterable(@PolyThread Observable<T> this, Func1<? super T,? extends Iterable<? extends R>> arg0);
    @PolyThread Observable<T> concatWith(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    @PolyThread Observable<Boolean> contains(@PolyThread Observable<T> this, Object arg0);
    @PolyThread Observable<Integer> count(@PolyThread Observable<T> this);
    @PolyThread Observable<Long> countLong(@PolyThread Observable<T> this);
    <U> @PolyThread Observable<T> debounce(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<U>> arg0);
    @PolyThread Observable<T> debounce(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> debounce(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> defaultIfEmpty(@PolyThread Observable<T> this, T arg0);
    @PolyThread Observable<T> switchIfEmpty(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    //    <U, V> Observable<T> delay(Func0<? extends Observable<U>> arg0, Func1<? super T,? extends Observable<V>> arg1);
    <U> @AnyThread Observable<T> delay(Func1<? super T,? extends Observable<U>> arg0);
    @AnyThread Observable<T> delay(long arg0, TimeUnit arg1);
    @PolyThread Observable<T> delay(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
    @AnyThread Observable<T> delaySubscription(long arg0, TimeUnit arg1);
    @PolyThread Observable<T> delaySubscription(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
    //    <U> Observable<T> delaySubscription(Func0<? extends Observable<U>> arg0);
    //    <U> Observable<T> delaySubscription(Observable<U> arg0);
    //    <T2> Observable<T2> dematerialize();
    @PolyThread Observable<T> distinct(@PolyThread Observable<T> this);
    <U> @PolyThread Observable<T> distinct(@PolyThread Observable<T> this, Func1<? super T,? extends U> arg0);
    @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this);
    <U> @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this, Func1<? super T,? extends U> arg0);

    //    @SubscribeEffects({0}) @PolyThread Observable<T> doAfterNext(@PolyThread Observable<T> this, @PolyUI Consumer<? super T> arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doAfterTerminate(@PolyThread Observable<T> this, @PolyUI Action arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doFinally(@PolyThread Observable<T> this, @PolyUI Action arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnDispose(@PolyThread Observable<T> this, @PolyUI Action arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnComplete(@PolyThread Observable<T> this, @PolyUI Action arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @PolyUI Consumer<? super Notification<T>> arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @PolyUI Observer<? super T> arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnError(@PolyThread Observable<T> this, @PolyUI Consumer<? super Throwable> arg0);
    //    @SubscribeEffects({0,1}) @PolyThread Observable<T> doOnLifecycle(@PolyThread Observable<T> this, @PolyUI Consumer<? super Disposable> arg0, @PolyUI Action arg1);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnNext(@PolyThread Observable<T> this, @PolyUI Consumer<? super T> arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnSubscribe(@PolyThread Observable<T> this, @PolyUI Consumer<? super Disposable> arg0);
    //    @SubscribeEffects({0}) @PolyThread Observable<T> doOnTerminate(@PolyThread Observable<T> this, @PolyUI Action arg0);

    @SubscribeEffects({0}) @PolyThread Observable<T> distinctUntilChanged(@PolyThread Observable<T> this, @UI Func2<? super T,? super T,Boolean> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnCompleted(@PolyThread Observable<T> this, @UI Action0 arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @UI Action1<Notification<? super T>> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnEach(@PolyThread Observable<T> this, @UI Observer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnError(@PolyThread Observable<T> this, @UI Action1<? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnNext(@PolyThread Observable<T> this, @UI Action1<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnRequest(@PolyThread Observable<T> this, @UI Action1<? super Long> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnSubscribe(@PolyThread Observable<T> this, @UI Action0 arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnTerminate(@PolyThread Observable<T> this, @UI Action0 arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> doOnUnsubscribe(@PolyThread Observable<T> this, @UI Action0 arg0);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7);
    //    static <T> Observable<T> concatEager(Observable<? extends T> arg0, Observable<? extends T> arg1, Observable<? extends T> arg2, Observable<? extends T> arg3, Observable<? extends T> arg4, Observable<? extends T> arg5, Observable<? extends T> arg6, Observable<? extends T> arg7, Observable<? extends T> arg8);
    //    static <T> Observable<T> concatEager(Iterable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concatEager(Iterable<? extends Observable<? extends T>> arg0, int arg1);
    //    static <T> Observable<T> concatEager(Observable<? extends Observable<? extends T>> arg0);
    //    static <T> Observable<T> concatEager(Observable<? extends Observable<? extends T>> arg0, int arg1);
    <R> @PolyThread Observable<R> concatMapEager(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    <R> @PolyThread Observable<R> concatMapEager(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0, int arg1);
    <R> @PolyThread Observable<R> concatMapEager(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0, int arg1, int arg2);
    @PolyThread Observable<T> elementAt(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> elementAtOrDefault(@PolyThread Observable<T> this, int arg0, T arg1);
    @PolyThread Observable<Boolean> exists(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> filter(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @SubscribeEffects({0}) @PolyThread Observable<T> filter(@PolyThread Observable<T> this, @PolyUI Func1<? super T,Boolean> arg0);    @SubscribeEffects({0}) @PolyThread Observable<T> doAfterTerminate(@PolyThread Observable<T> this, Action0 arg0);
    @PolyThread Observable<T> first(@PolyThread Observable<T> this);
    @PolyThread Observable<T> first(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> firstOrDefault(@PolyThread Observable<T> this, T arg0);
    @PolyThread Observable<T> firstOrDefault(@PolyThread Observable<T> this, T arg0, Func1<? super T,Boolean> arg1);
    <R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    <R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0, int arg1);
    <R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0, Func1<? super Throwable,? extends Observable<? extends R>> arg1, Func0<? extends Observable<? extends R>> arg2);
    <R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0, Func1<? super Throwable,? extends Observable<? extends R>> arg1, Func0<? extends Observable<? extends R>> arg2, int arg3);
    <U, R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends U>> arg0, Func2<? super T,? super U,? extends R> arg1);
    <U, R> @AnyThread Observable<R> flatMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends U>> arg0, Func2<? super T,? super U,? extends R> arg1, int arg2);
    @AnyThread Observable<T> flatMapCompletable(@AnyThread Observable<T> this, Func1<? super T,? extends Completable> arg0);
    @AnyThread Observable<T> flatMapCompletable(@AnyThread Observable<T> this, Func1<? super T,? extends Completable> arg0, boolean arg1);
    @AnyThread Observable<T> flatMapCompletable(@AnyThread Observable<T> this, Func1<? super T,? extends Completable> arg0, boolean arg1, int arg2);
    <R> @AnyThread Observable<R> flatMapIterable(@AnyThread Observable<T> this, Func1<? super T,? extends Iterable<? extends R>> arg0);
    <R> @AnyThread Observable<R> flatMapIterable(@AnyThread Observable<T> this, Func1<? super T,? extends Iterable<? extends R>> arg0, int arg1);
    <U, R> @AnyThread Observable<R> flatMapIterable(@AnyThread Observable<T> this, Func1<? super T,? extends Iterable<? extends U>> arg0, Func2<? super T,? super U,? extends R> arg1);
    <U, R> @AnyThread Observable<R> flatMapIterable(@AnyThread Observable<T> this, Func1<? super T,? extends Iterable<? extends U>> arg0, Func2<? super T,? super U,? extends R> arg1, int arg2);
    <R> @AnyThread Observable<R> flatMapSingle(@AnyThread Observable<T> this, Func1<? super T,? extends Single<? extends R>> arg0);
    <R> @AnyThread Observable<R> flatMapSingle(@AnyThread Observable<T> this, Func1<? super T,? extends Single<? extends R>> arg0, boolean arg1);
    <R> @AnyThread Observable<R> flatMapSingle(@AnyThread Observable<T> this, Func1<? super T,? extends Single<? extends R>> arg0, boolean arg1, int arg2);
    //    void forEach(Action1<? super T> arg0);
    //    void forEach(Action1<? super T> arg0, Action1<Throwable> arg1);
    //    void forEach(Action1<? super T> arg0, Action1<Throwable> arg1, Action0 arg2);
    //    <K, R> Observable<GroupedObservable<K,R>> groupBy(Func1<? super T,? extends K> arg0, Func1<? super T,? extends R> arg1);
    //    <K, R> Observable<GroupedObservable<K,R>> groupBy(Func1<? super T,? extends K> arg0, Func1<? super T,? extends R> arg1, Func1<Action1<K>,Map<K,Object>> arg2);
    <K> @PolyThread Observable<GroupedObservable<K,T>> groupBy(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0);
    //    <T2, D1, D2, R> Observable<R> groupJoin(Observable<T2> arg0, Func1<? super T,? extends Observable<D1>> arg1, Func1<? super T2,? extends Observable<D2>> arg2, Func2<? super T,? super Observable<T2>,? extends R> arg3);
    @PolyThread Observable<T> ignoreElements(@PolyThread Observable<T> this);
    @PolyThread Observable<Boolean> isEmpty(@PolyThread Observable<T> this);
    //    <TRight, TLeftDuration, TRightDuration, R> Observable<R> join(Observable<TRight> arg0, Func1<T,Observable<TLeftDuration>> arg1, Func1<TRight,Observable<TRightDuration>> arg2, Func2<T,TRight,R> arg3);
    @PolyThread Observable<T> last(@PolyThread Observable<T> this);
    @PolyThread Observable<T> last(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> lastOrDefault(@PolyThread Observable<T> this, T arg0);
    @PolyThread Observable<T> lastOrDefault(@PolyThread Observable<T> this, T arg0, Func1<? super T,Boolean> arg1);
    @PolyThread Observable<T> limit(@PolyThread Observable<T> this, int arg0);
    @SubscribeEffects({0}) <R> @PolyThread Observable<R> map(@PolyThread Observable<T> this, @PolyUI Func1<? super T,? extends R> arg0);
    //    Observable<Notification<T>> materialize();
    @PolyThread Observable<T> mergeWith(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0, int arg1);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0, boolean arg1);
    @PolyThread Observable<T> observeOn(@PolyThread Scheduler arg0, boolean arg1, int arg2);
    <R> @PolyThread Observable<R> ofType(@PolyThread Observable<T> this, Class<R> arg0);
    @PolyThread Observable<T> onBackpressureBuffer(@PolyThread Observable<T> this);
    @PolyThread Observable<T> onBackpressureBuffer(@PolyThread Observable<T> this, long arg0);
    @PolyThread Observable<T> onBackpressureBuffer(@PolyThread Observable<T> this, long arg0, Action0 arg1);
    @PolyThread Observable<T> onBackpressureBuffer(@PolyThread Observable<T> this, long arg0, Action0 arg1, Strategy arg2);
    @PolyThread Observable<T> onBackpressureDrop(@PolyThread Observable<T> this, Action1<? super T> arg0);
    @PolyThread Observable<T> onBackpressureDrop(@PolyThread Observable<T> this);
    @PolyThread Observable<T> onBackpressureLatest(@PolyThread Observable<T> this);
    @PolyThread Observable<T> onErrorResumeNext(@PolyThread Observable<T> this, Func1<? super Throwable,? extends Observable<? extends T>> arg0);
    @PolyThread Observable<T> onErrorResumeNext(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    @PolyThread Observable<T> onErrorReturn(@PolyThread Observable<T> this, Func1<? super Throwable,? extends T> arg0);
    @PolyThread Observable<T> onExceptionResumeNext(@PolyThread Observable<T> this, Observable<? extends T> arg0);
    @PolyThread Observable<T> onTerminateDetach(@PolyThread Observable<T> this);
    @PolyThread ConnectableObservable<T> publish(@PolyThread Observable<T> this);
    <R> @PolyThread Observable<R> publish(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0);
    @PolyThread Observable<T> rebatchRequests(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> reduce(@PolyThread Observable<T> this, Func2<T,T,T> arg0);
    <R> @PolyThread Observable<R> reduce(@PolyThread Observable<T> this, R arg0, Func2<R,? super T,R> arg1);
    @PolyThread Observable<T> repeat(@PolyThread Observable<T> this);
    @PolyThread Observable<T> repeat(@PolyThread Observable<T> this, Scheduler arg0);
    @PolyThread Observable<T> repeat(@PolyThread Observable<T> this, long arg0);
    @PolyThread Observable<T> repeat(@PolyThread Observable<T> this, long arg0, Scheduler arg1);
    @PolyThread Observable<T> repeatWhen(@PolyThread Observable<T> this, Func1<? super Observable<? extends Void>,? extends Observable<?>> arg0, Scheduler arg1);
    @PolyThread Observable<T> repeatWhen(@PolyThread Observable<T> this, Func1<? super Observable<? extends Void>,? extends Observable<?>> arg0);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, int arg1);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, int arg1, long arg2, TimeUnit arg3);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, int arg1, long arg2, TimeUnit arg3, Scheduler arg4);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, int arg1, Scheduler arg2);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, long arg1, TimeUnit arg2);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    <R> @PolyThread Observable<R> replay(@PolyThread Observable<T> this, Func1<? super Observable<T>,? extends Observable<R>> arg0, Scheduler arg1);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, int arg0);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, int arg0, Scheduler arg1);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread ConnectableObservable<T> replay(@PolyThread Observable<T> this, Scheduler arg0);
    @PolyThread Observable<T> retry(@PolyThread Observable<T> this);
    @PolyThread Observable<T> retry(@PolyThread Observable<T> this, long arg0);
    @PolyThread Observable<T> retry(@PolyThread Observable<T> this, Func2<Integer,Throwable,Boolean> arg0);
    @PolyThread Observable<T> retryWhen(@PolyThread Observable<T> this, Func1<? super Observable<? extends Throwable>,? extends Observable<?>> arg0);
    @PolyThread Observable<T> retryWhen(@PolyThread Observable<T> this, Func1<? super Observable<? extends Throwable>,? extends Observable<?>> arg0, Scheduler arg1);
    @PolyThread Observable<T> sample(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> sample(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <U> @PolyThread Observable<T> sample(@PolyThread Observable<T> this, Observable<U> arg0);
    @PolyThread Observable<T> scan(@PolyThread Observable<T> this, Func2<T,T,T> arg0);
    <R> @PolyThread Observable<R> scan(@PolyThread Observable<T> this, R arg0, Func2<R,? super T,R> arg1);
    @PolyThread Observable<T> serialize(@PolyThread Observable<T> this);
    @PolyThread Observable<T> share(@PolyThread Observable<T> this);
    @PolyThread Observable<T> single(@PolyThread Observable<T> this);
    @PolyThread Observable<T> single(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> singleOrDefault(@PolyThread Observable<T> this, T arg0);
    @PolyThread Observable<T> singleOrDefault(@PolyThread Observable<T> this, T arg0, Func1<? super T,Boolean> arg1);
    @PolyThread Observable<T> skip(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> skip(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> skip(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> skipLast(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> skipLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> skipLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <U> @PolyThread Observable<T> skipUntil(@PolyThread Observable<T> this, Observable<U> arg0);
    @PolyThread Observable<T> skipWhile(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, Observable<T> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, Iterable<T> arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3, T arg4);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3, T arg4, T arg5);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7);
    @PolyThread Observable<T> startWith(@PolyThread Observable<T> this, T arg0, T arg1, T arg2, T arg3, T arg4, T arg5, T arg6, T arg7, T arg8);
    //    Subscription subscribe();
    @SubscribeEffects({0}) Subscription subscribe(@UI Action1<? super T> arg0);
    @SubscribeEffects({0,1}) Subscription subscribe(@UI Action1<? super T> arg0, @UI Action1<Throwable> arg1);
    @SubscribeEffects({0,1,2}) Subscription subscribe(@UI Action1<? super T> arg0, @UI Action1<Throwable> arg1, @UI Action0 arg2);
    @SubscribeEffects({0}) Subscription subscribe(@UI Observer<? super T> arg0);
    @SubscribeEffects({0}) Subscription unsafeSubscribe(@UI Subscriber<? super T> arg0);
    @SubscribeEffects({0}) Subscription subscribe(@UI Subscriber<? super T> arg0);
    //    Observable<T> subscribeOn(Scheduler arg0);
    //    Observable<T> subscribeOn(Scheduler arg0, boolean arg1);
    <R> @AnyThread Observable<R> switchMap(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    <R> @AnyThread Observable<R> switchMapDelayError(@AnyThread Observable<T> this, Func1<? super T,? extends Observable<? extends R>> arg0);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> take(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> takeFirst(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> takeLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<List<T>> takeLastBuffer(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<List<T>> takeLastBuffer(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2);
    @PolyThread Observable<List<T>> takeLastBuffer(@PolyThread Observable<T> this, int arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    @PolyThread Observable<List<T>> takeLastBuffer(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<List<T>> takeLastBuffer(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <E> @PolyThread Observable<T> takeUntil(@PolyThread Observable<T> this, Observable<? extends E> arg0);
    @PolyThread Observable<T> takeWhile(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> takeUntil(@PolyThread Observable<T> this, Func1<? super T,Boolean> arg0);
    @PolyThread Observable<T> throttleFirst(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> throttleFirst(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> throttleLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> throttleLast(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<T> throttleWithTimeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> throttleWithTimeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<TimeInterval<T>> timeInterval(@PolyThread Observable<T> this);
    @PolyThread Observable<TimeInterval<T>> timeInterval(@PolyThread Observable<T> this, Scheduler arg0);
    <U, V> @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, Func0<? extends Observable<U>> arg0, Func1<? super T,? extends Observable<V>> arg1);
    <U, V> @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, Func0<? extends Observable<U>> arg0, Func1<? super T,? extends Observable<V>> arg1, Observable<? extends T> arg2);
    <V> @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<V>> arg0);
    <V> @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, Func1<? super T,? extends Observable<V>> arg0, Observable<? extends T> arg1);
    @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Observable<? extends T> arg2);
    @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Observable<? extends T> arg2, Scheduler arg3);
    @PolyThread Observable<T> timeout(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Observable<Timestamped<T>> timestamp(@PolyThread Observable<T> this);
    @PolyThread Observable<Timestamped<T>> timestamp(@PolyThread Observable<T> this, Scheduler arg0);
    @PolyThread BlockingObservable<T> toBlocking(@PolyThread Observable<T> this);
    @PolyThread Observable<List<T>> toList(@PolyThread Observable<T> this);
    <K> @PolyThread Observable<Map<K,T>> toMap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0);
    <K, V> @PolyThread Observable<Map<K,V>> toMap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0, Func1<? super T,? extends V> arg1);
    <K, V> @PolyThread Observable<Map<K,V>> toMap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0, Func1<? super T,? extends V> arg1, Func0<? extends Map<K,V>> arg2);
    <K> @PolyThread Observable<Map<K,Collection<T>>> toMultimap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0);
    <K, V> @PolyThread Observable<Map<K,Collection<V>>> toMultimap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0, Func1<? super T,? extends V> arg1);
    <K, V> @PolyThread Observable<Map<K,Collection<V>>> toMultimap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0, Func1<? super T,? extends V> arg1, Func0<? extends Map<K,Collection<V>>> arg2);
    <K, V> @PolyThread Observable<Map<K,Collection<V>>> toMultimap(@PolyThread Observable<T> this, Func1<? super T,? extends K> arg0, Func1<? super T,? extends V> arg1, Func0<? extends Map<K,Collection<V>>> arg2, Func1<? super K,? extends Collection<V>> arg3);
    @PolyThread Observable<List<T>> toSortedList(@PolyThread Observable<T> this);
    @PolyThread Observable<List<T>> toSortedList(@PolyThread Observable<T> this, Func2<? super T,? super T,Integer> arg0);
    @PolyThread Observable<List<T>> toSortedList(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<List<T>> toSortedList(@PolyThread Observable<T> this, Func2<? super T,? super T,Integer> arg0, int arg1);
    @PolyThread Observable<T> sorted(@PolyThread Observable<T> this);
    @PolyThread Observable<T> sorted(@PolyThread Observable<T> this, Func2<? super T,? super T,Integer> arg0);
    //    Observable<T> unsubscribeOn(Scheduler arg0);
     <U, R> @PolyThread Observable<R> withLatestFrom(@PolyThread Observable<T> this, Observable<? extends U> arg0, Func2<? super T,? super U,? extends R> arg1);
    //    <T1, T2, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Func3<? super T,? super T1,? super T2,R> arg2);
    //    <T1, T2, T3, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Func4<? super T,? super T1,? super T2,? super T3,R> arg3);
    //    <T1, T2, T3, T4, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Observable<T4> arg3, Func5<? super T,? super T1,? super T2,? super T3,? super T4,R> arg4);
    //    <T1, T2, T3, T4, T5, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Observable<T4> arg3, Observable<T5> arg4, Func6<? super T,? super T1,? super T2,? super T3,? super T4,? super T5,R> arg5);
    //    <T1, T2, T3, T4, T5, T6, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Observable<T4> arg3, Observable<T5> arg4, Observable<T6> arg5, Func7<? super T,? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,R> arg6);
    //    <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Observable<T4> arg3, Observable<T5> arg4, Observable<T6> arg5, Observable<T7> arg6, Func8<? super T,? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,R> arg7);
    //    <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> withLatestFrom(Observable<T1> arg0, Observable<T2> arg1, Observable<T3> arg2, Observable<T4> arg3, Observable<T5> arg4, Observable<T6> arg5, Observable<T7> arg6, Observable<T8> arg7, Func9<? super T,? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,R> arg8);
    <R> @PolyThread Observable<R> withLatestFrom(@PolyThread Observable<T> this, Observable<?>[] arg0, FuncN<R> arg1);
    <R> @PolyThread Observable<R> withLatestFrom(@PolyThread Observable<T> this, Iterable<Observable<?>> arg0, FuncN<R> arg1);
    //    <TClosing> Observable<Observable<T>> window(Func0<? extends Observable<? extends TClosing>> arg0);
    @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, int arg0);
    @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, int arg0, int arg1);
    @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, long arg0, long arg1, TimeUnit arg2);
    @PolyThread Observable<Observable<T>> window(long arg0, long arg1, TimeUnit arg2, @PolyThread Scheduler arg3);
    @PolyThread Observable<Observable<T>> window(long arg0, long arg1, TimeUnit arg2, int arg3, @PolyThread Scheduler arg4);
    @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, long arg0, TimeUnit arg1);
    @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, long arg0, TimeUnit arg1, int arg2);
    @PolyThread Observable<Observable<T>> window(long arg0, TimeUnit arg1, int arg2, @PolyThread Scheduler arg3);
    @PolyThread Observable<Observable<T>> window(long arg0, TimeUnit arg1, @PolyThread Scheduler arg2);
    //    <TOpening, TClosing> Observable<Observable<T>> window(Observable<? extends TOpening> arg0, Func1<? super TOpening,? extends Observable<? extends TClosing>> arg1);
    <U> @PolyThread Observable<Observable<T>> window(@PolyThread Observable<T> this, Observable<U> arg0);
     <T2, R> @PolyThread Observable<R> zipWith(@PolyThread Observable<T> this, Iterable<? extends T2> arg0, Func2<? super T,? super T2,? extends R> arg1);
     <T2, R> @PolyThread Observable<R> zipWith(@PolyThread Observable<T> this, Observable<? extends T2> arg0, Func2<? super T,? super T2,? extends R> arg1);
    //    AssertableSubscriber<T> test();
    //    AssertableSubscriber<T> test(long arg0);
}
interface Observable$Transformer<T, R> extends Func1<Observable<T>,Observable<R>> {
}
interface Observable$Operator<R, T> extends Func1<Subscriber<? super R>,Subscriber<? super T>> {
}
interface Observable$OnSubscribe<T> extends Action1<Subscriber<? super T>> {
}
