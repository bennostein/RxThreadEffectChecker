import org.checkerframework.checker.guieffect.qual.*;
import com.ubercab.rxthreadchecker.qual.*;

package io.reactivex;

class Single<T> implements SingleSource<T> {
    //    Single();
    //    static <T> Single<T> amb(Iterable<? extends SingleSource<? extends T>> arg0);
    //    static <T> Single<T> ambArray(SingleSource<? extends T>[] arg0);
    //    static <T> Flowable<T> concat(Iterable<? extends SingleSource<? extends T>> arg0);
    //    static <T> Observable<T> concat(ObservableSource<? extends SingleSource<? extends T>> arg0);
    //    static <T> Flowable<T> concat(Publisher<? extends SingleSource<? extends T>> arg0);
    //    static <T> Flowable<T> concat(Publisher<? extends SingleSource<? extends T>> arg0, int arg1);
    //    static <T> Flowable<T> concat(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1);
    //    static <T> Flowable<T> concat(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1, SingleSource<? extends T> arg2);
    //    static <T> Flowable<T> concat(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1, SingleSource<? extends T> arg2, SingleSource<? extends T> arg3);
    //    static <T> Flowable<T> concatArray(SingleSource<? extends T>[] arg0);
    //    static <T> Single<T> create(SingleOnSubscribe<T> arg0);
    //    static <T> Single<T> defer(Callable<? extends SingleSource<? extends T>> arg0);
    //    static <T> Single<T> error(Callable<? extends Throwable> arg0);
    //    static <T> Single<T> error(Throwable arg0);
    //    static <T> Single<T> fromCallable(Callable<? extends T> arg0);
    //    static <T> Single<T> fromFuture(Future<? extends T> arg0);
    //    static <T> Single<T> fromFuture(Future<? extends T> arg0, long arg1, TimeUnit arg2);
    //    static <T> Single<T> fromFuture(Future<? extends T> arg0, long arg1, TimeUnit arg2, Scheduler arg3);
    //    static <T> Single<T> fromFuture(Future<? extends T> arg0, Scheduler arg1);
    //    static <T> Single<T> fromPublisher(Publisher<? extends T> arg0);
    //    static <T> Single<T> fromObservable(ObservableSource<? extends T> arg0);
    //    static <T> Single<T> just(T arg0);
    //    static <T> Flowable<T> merge(Iterable<? extends SingleSource<? extends T>> arg0);
    //    static <T> Flowable<T> merge(Publisher<? extends SingleSource<? extends T>> arg0);
    //    static <T> Single<T> merge(SingleSource<? extends SingleSource<? extends T>> arg0);
    //    static <T> Flowable<T> merge(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1);
    //    static <T> Flowable<T> merge(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1, SingleSource<? extends T> arg2);
    //    static <T> Flowable<T> merge(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1, SingleSource<? extends T> arg2, SingleSource<? extends T> arg3);
    //    static <T> Single<T> never();
    //    static Single<Long> timer(long arg0, TimeUnit arg1);
    //    static Single<Long> timer(long arg0, TimeUnit arg1, Scheduler arg2);
    //    static <T> Single<Boolean> equals(SingleSource<? extends T> arg0, SingleSource<? extends T> arg1);
    //    static <T> Single<T> unsafeCreate(SingleSource<T> arg0);
    //    static <T, U> Single<T> using(Callable<U> arg0, Function<? super U,? extends SingleSource<? extends T>> arg1, Consumer<? super U> arg2);
    //    static <T, U> Single<T> using(Callable<U> arg0, Function<? super U,? extends SingleSource<? extends T>> arg1, Consumer<? super U> arg2, boolean arg3);
    //    static <T> Single<T> wrap(SingleSource<T> arg0);
    //    static <T, R> Single<R> zip(Iterable<? extends SingleSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
    //    static <T1, T2, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2);
    //    static <T1, T2, T3, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, Function3<? super T1,? super T2,? super T3,? extends R> arg3);
    //    static <T1, T2, T3, T4, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, Function4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
    //    static <T1, T2, T3, T4, T5, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, SingleSource<? extends T5> arg4, Function5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
    //    static <T1, T2, T3, T4, T5, T6, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, SingleSource<? extends T5> arg4, SingleSource<? extends T6> arg5, Function6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
    //    static <T1, T2, T3, T4, T5, T6, T7, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, SingleSource<? extends T5> arg4, SingleSource<? extends T6> arg5, SingleSource<? extends T7> arg6, Function7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, SingleSource<? extends T5> arg4, SingleSource<? extends T6> arg5, SingleSource<? extends T7> arg6, SingleSource<? extends T8> arg7, Function8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Single<R> zip(SingleSource<? extends T1> arg0, SingleSource<? extends T2> arg1, SingleSource<? extends T3> arg2, SingleSource<? extends T4> arg3, SingleSource<? extends T5> arg4, SingleSource<? extends T6> arg5, SingleSource<? extends T7> arg6, SingleSource<? extends T8> arg7, SingleSource<? extends T9> arg8, Function9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
    //    static <T, R> Single<R> zipArray(Function<? super Object[],? extends R> arg0, SingleSource<? extends T>[] arg1);
    @PolyThread Single<T> ambWith(@PolyThread Single<T> this, SingleSource<? extends T> arg0);
    <R> @PolyThread R as(@PolyThread Single<T> this, SingleConverter<T, ? extends R> converter);
    @PolyThread Single<T> hide(@PolyThread Single<T> this);
    <R> @PolyThread Single<R> compose(@PolyThread Single<T> this, SingleTransformer<? super T,? extends R> arg0);
    //    Single<T> cache();
    <U> @PolyThread Single<U> cast(@PolyThread Single<T> this, Class<? extends U> arg0);
    @PolyThread Flowable<T> concatWith(@PolyThread Single<T> this, SingleSource<? extends T> arg0);
    @AnyThread Single<T> delay(@AnyThread Single<T> this, long arg0, TimeUnit arg1);
    @AnyThread Single<T> delay(@AnyThread Single<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, CompletableSource arg0);
    @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, long arg0, TimeUnit arg1);
    @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <U> @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, SingleSource<U> arg0);
    <U> @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, ObservableSource<U> arg0);
    <U> @PolyThread Single<T> delaySubscription(@PolyThread Single<T> this, Publisher<U> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doAfterSuccess(@PolyThread Single<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doAfterTerminate(@PolyThread Single<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doFinally(@PolyThread Single<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doOnSubscribe(@PolyThread Single<T> this, @UI Consumer<? super Disposable> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doOnSuccess(@PolyThread Single<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doOnEvent(@PolyThread Single<T> this, @UI BiConsumer<? super T,? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doOnError(@PolyThread Single<T> this, @UI Consumer<? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Single<T> doOnDispose(@PolyThread Single<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> filter(@PolyThread Single<T> this, @PolyUI Predicate<? super T> arg0);
    <R> @AnyThread Single<R> flatMap(@AnyThread Single<T> this, @AlwaysSafe Function<? super T,? extends SingleSource<? extends R>> arg0);
    <R> @AnyThread Maybe<R> flatMapMaybe(@AnyThread Single<T> this, Function<? super T,? extends MaybeSource<? extends R>> arg0);
    <R> @AnyThread Flowable<R> flatMapPublisher(@AnyThread Single<T> this, Function<? super T,? extends Publisher<? extends R>> arg0);
    <U> @PolyThread Flowable<U> flattenAsFlowable(@PolyThread Single<T> this, Function<? super T,? extends Iterable<? extends U>> arg0);
    <U> @PolyThread Observable<U> flattenAsObservable(@PolyThread Single<T> this, Function<? super T,? extends Iterable<? extends U>> arg0);
    <R> @AnyThread Observable<R> flatMapObservable(@AnyThread Single<T> this, Function<? super T,? extends ObservableSource<? extends R>> arg0);
    @AnyThread Completable flatMapCompletable(@AnyThread Single<T> this, Function<? super T,? extends CompletableSource> arg0);
    //    T blockingGet();
    <R> @PolyThread Single<R> lift(@PolyThread Single<T> this, SingleOperator<? extends R,? super T> arg0);
    <R> @PolyThread Single<R> map(@PolyThread Single<T> this, Function<? super T,? extends R> arg0);
    @PolyThread Single<Boolean> contains(@PolyThread Single<T> this, Object arg0);
    @PolyThread Single<Boolean> contains(@PolyThread Single<T> this, Object arg0, BiPredicate<Object,Object> arg1);
    @PolyThread Flowable<T> mergeWith(@PolyThread Single<T> this, SingleSource<? extends T> arg0);
    @PolyThread Single<T> observeOn(@AnyThread Single<T> this, @PolyThread Scheduler arg0);
    @PolyThread Single<T> onErrorReturn(@PolyThread Single<T> this, Function<Throwable,? extends T> arg0);
    @PolyThread Single<T> onErrorReturnItem(@PolyThread Single<T> this, T arg0);
    @PolyThread Single<T> onErrorResumeNext(@PolyThread Single<T> this, Single<? extends T> arg0);
    @PolyThread Single<T> onErrorResumeNext(@PolyThread Single<T> this, Function<? super Throwable,? extends SingleSource<? extends T>> arg0);
    @PolyThread Flowable<T> repeat(@PolyThread Single<T> this);
    @PolyThread Flowable<T> repeat(@PolyThread Single<T> this, long arg0);
    @PolyThread Flowable<T> repeatWhen(@PolyThread Single<T> this, Function<? super Flowable<Object>,? extends Publisher<?>> arg0);
    @PolyThread Flowable<T> repeatUntil(@PolyThread Single<T> this, BooleanSupplier arg0);
    @PolyThread Single<T> retry(@PolyThread Single<T> this);
    @PolyThread Single<T> retry(@PolyThread Single<T> this, long arg0);
    @PolyThread Single<T> retry(@PolyThread Single<T> this, BiPredicate<? super Integer,? super Throwable> arg0);
    @PolyThread Single<T> retry(@PolyThread Single<T> this, Predicate<? super Throwable> arg0);
    @PolyThread Single<T> retryWhen(@PolyThread Single<T> this, Function<? super Flowable<Throwable>,? extends Publisher<?>> arg0);
    //    Disposable subscribe();
    @SubscribeEffects({0}) Disposable subscribe(@UI BiConsumer<? super T,? super Throwable> arg0);
    @SubscribeEffects({0}) Disposable subscribe(@UI Consumer<? super T> arg0);
    @SubscribeEffects({0,1}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1);
    @SubscribeEffects({0}) void subscribe(@UI SingleObserver<? super T> arg0);
    @SubscribeEffects({0}) protected void subscribeActual(@UI SingleObserver<? super T> arg0);
    @SubscribeEffects({0}) <E> E subscribeWith(@UI E arg0);
    //    Single<T> subscribeOn(Scheduler arg0);
    @PolyThread Single<T> takeUntil(@PolyThread Single<T> this, CompletableSource arg0);
    <E> @PolyThread Single<T> takeUntil(@PolyThread Single<T> this, Publisher<E> arg0);
    <E> @PolyThread Single<T> takeUntil(@PolyThread Single<T> this, SingleSource<? extends E> arg0);
    @PolyThread Single<T> timeout(@PolyThread Single<T> this, long arg0, TimeUnit arg1);
    @PolyThread Single<T> timeout(@PolyThread Single<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Single<T> timeout(@PolyThread Single<T> this, long arg0, TimeUnit arg1, Scheduler arg2, SingleSource<? extends T> arg3);
    @PolyThread Single<T> timeout(@PolyThread Single<T> this, long arg0, TimeUnit arg1, SingleSource<? extends T> arg2);
    <R> @PolyThread R to(@PolyThread Single<T> this, Function<? super Single<T>,R> arg0);
    @PolyThread Completable toCompletable(@PolyThread Single<T> this);
    @PolyThread Flowable<T> toFlowable(@PolyThread Single<T> this);
    @PolyThread Future<T> toFuture(@PolyThread Single<T> this);
    @PolyThread Maybe<T> toMaybe(@PolyThread Single<T> this);
    @PolyThread Observable<T> toObservable(@PolyThread Single<T> this);
    //    Single<T> unsubscribeOn(Scheduler arg0);
    <U, R> @PolyThread Single<R> zipWith(@PolyThread Single<T> this, SingleSource<U> arg0, BiFunction<? super T,? super U,? extends R> arg1);
    //    TestObserver<T> test();
    //    TestObserver<T> test(boolean arg0);
}
