import org.checkerframework.checker.guieffect.qual.*;
import com.ubercab.rxthreadchecker.qual.*;

package io.reactivex;

class Completable implements CompletableSource {
    //    Completable();
    //    static Completable ambArray(CompletableSource[] arg0);
    //    static Completable amb(Iterable<? extends CompletableSource> arg0);
    //    static Completable complete();
    //    static Completable concatArray(CompletableSource[] arg0);
    //    static Completable concat(Iterable<? extends CompletableSource> arg0);
    //    static Completable concat(Publisher<? extends CompletableSource> arg0);
    //    static Completable concat(Publisher<? extends CompletableSource> arg0, int arg1);
    //    static Completable create(CompletableOnSubscribe arg0);
    //    static Completable unsafeCreate(CompletableSource arg0);
    //    static Completable defer(Callable<? extends CompletableSource> arg0);
    //    static Completable error(Callable<? extends Throwable> arg0);
    //    static Completable error(Throwable arg0);
    //    static Completable fromAction(Action arg0);
    //    static Completable fromCallable(Callable<?> arg0);
    //    static Completable fromFuture(Future<?> arg0);
    //    static Completable fromRunnable(Runnable arg0);
    //    static <T> Completable fromObservable(ObservableSource<T> arg0);
    //    static <T> Completable fromPublisher(Publisher<T> arg0);
    //    static <T> Completable fromSingle(SingleSource<T> arg0);
    //    static Completable mergeArray(CompletableSource[] arg0);
    //    static Completable merge(Iterable<? extends CompletableSource> arg0);
    //    static Completable merge(Publisher<? extends CompletableSource> arg0);
    //    static Completable merge(Publisher<? extends CompletableSource> arg0, int arg1);
    //    static Completable mergeArrayDelayError(CompletableSource[] arg0);
    //    static Completable mergeDelayError(Iterable<? extends CompletableSource> arg0);
    //    static Completable mergeDelayError(Publisher<? extends CompletableSource> arg0);
    //    static Completable mergeDelayError(Publisher<? extends CompletableSource> arg0, int arg1);
    //    static Completable never();
    //    static Completable timer(long arg0, TimeUnit arg1);
    //    static Completable timer(long arg0, TimeUnit arg1, Scheduler arg2);
    //    static <R> Completable using(Callable<R> arg0, Function<? super R,? extends CompletableSource> arg1, Consumer<? super R> arg2);
    //    static <R> Completable using(Callable<R> arg0, Function<? super R,? extends CompletableSource> arg1, Consumer<? super R> arg2, boolean arg3);
    //    static Completable wrap(CompletableSource arg0);
    @PolyThread Completable ambWith(@PolyThread Completable this, CompletableSource arg0);
    <T> @PolyThread Observable<T> andThen(@PolyThread Completable this, ObservableSource<T> arg0);
    <T> @PolyThread Flowable<T> andThen(@PolyThread Completable this, Publisher<T> arg0);
    <T> @PolyThread Single<T> andThen(@PolyThread Completable this, SingleSource<T> arg0);
    @PolyThread <T> Maybe<T> andThen(@PolyThread Completable this, MaybeSource<T> arg0);
    @PolyThread Completable andThen(@PolyThread Completable this, CompletableSource arg0);
    <R> @PolyThread R as(@PolyThread Completable this, CompletableConverter<? extends R> converter);
    //    void blockingAwait();
    //    boolean blockingAwait(long arg0, TimeUnit arg1);
    //    Throwable blockingGet();
    //    Throwable blockingGet(long arg0, TimeUnit arg1);
    @PolyThread Completable cache(@PolyThread Completable this);
    @PolyThread Completable compose(@PolyThread Completable this, CompletableTransformer arg0);
    @PolyThread Completable concatWith(@PolyThread Completable this, CompletableSource arg0);
    @AnyThread Completable delay(long arg0, TimeUnit arg1);
    @AnyThread Completable delay(long arg0, TimeUnit arg1, Scheduler arg2);
    @AnyThread Completable delay(long arg0, TimeUnit arg1, Scheduler arg2, boolean arg3);
    @SubscribeEffects({0}) @PolyThread Completable doOnComplete(@PolyThread Completable this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Completable doOnDispose(@PolyThread Completable this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Completable doOnError(@PolyThread Completable this, @UI Consumer<? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Completable doOnEvent(@PolyThread Completable this, @UI Consumer<? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Completable doOnSubscribe(@PolyThread Completable this, @UI Consumer<? super Disposable> arg0);
    @SubscribeEffects({0}) @PolyThread Completable doOnTerminate(@PolyThread Completable this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Completable doAfterTerminate(@PolyThread Completable this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Completable doFinally(@PolyThread Completable this, @UI Action arg0);
    @PolyThread Completable lift(@PolyThread Completable this, CompletableOperator arg0);
    @PolyThread Completable mergeWith(@PolyThread Completable this, CompletableSource arg0);
    @PolyThread Completable observeOn(@PolyThread Scheduler arg0);
    @PolyThread Completable onErrorComplete();
    @PolyThread Completable onErrorComplete(@PolyThread Completable this, Predicate<? super Throwable> arg0);
    @PolyThread Completable onErrorResumeNext(@PolyThread Completable this, Function<? super Throwable,? extends CompletableSource> arg0);
    @PolyThread Completable repeat(@PolyThread Completable this);
    @PolyThread Completable repeat(@PolyThread Completable this, long arg0);
    @PolyThread Completable repeatUntil(@PolyThread Completable this, BooleanSupplier arg0);
    @PolyThread Completable repeatWhen(@PolyThread Completable this, Function<? super Flowable<Object>,? extends Publisher<?>> arg0);
    @PolyThread Completable retry(@PolyThread Completable this);
    @PolyThread Completable retry(@PolyThread Completable this, BiPredicate<? super Integer,? super Throwable> arg0);
    @PolyThread Completable retry(@PolyThread Completable this, long arg0);
    @PolyThread Completable retry(@PolyThread Completable this, Predicate<? super Throwable> arg0);
    @PolyThread Completable retryWhen(@PolyThread Completable this, Function<? super Flowable<Throwable>,? extends Publisher<?>> arg0);
    @PolyThread Completable startWith(@PolyThread Completable this, CompletableSource arg0);
    <T> @PolyThread Observable<T> startWith(@PolyThread Completable this, Observable<T> arg0);
    <T> @PolyThread Flowable<T> startWith(@PolyThread Completable this, Publisher<T> arg0);
    @PolyThread Completable hide(@PolyThread Completable this);
    //    Disposable subscribe();
    @SubscribeEffects({0}) void subscribe(@UI CompletableObserver arg0);
    //    protected void subscribeActual(CompletableObserver arg0);
    @SubscribeEffects({0}) <E> E subscribeWith(@UI E arg0);
    @SubscribeEffects({0,1}) Disposable subscribe(@UI Action arg0, @UI Consumer<? super Throwable> arg1);
    @SubscribeEffects({0})   Disposable subscribe(@UI Action arg0);
    //    Completable subscribeOn(Scheduler arg0);
    @PolyThread Completable timeout(@PolyThread Completable this, long arg0, TimeUnit arg1);
    @PolyThread Completable timeout(@PolyThread Completable this, long arg0, TimeUnit arg1, CompletableSource arg2);
    @PolyThread Completable timeout(@PolyThread Completable this, long arg0, TimeUnit arg1, Scheduler arg2);
    @PolyThread Completable timeout(@PolyThread Completable this, long arg0, TimeUnit arg1, Scheduler arg2, CompletableSource arg3);
    <U> @PolyThread U to(@PolyThread Completable this, Function<? super Completable,U> arg0);
    <T> @PolyThread Flowable<T> toFlowable(@PolyThread Completable this);
    <T> @PolyThread Maybe<T> toMaybe(@PolyThread Completable this);
    <T> @PolyThread Observable<T> toObservable(@PolyThread Completable this);
    <T> @PolyThread Single<T> toSingle(@PolyThread Completable this, Callable<? extends T> arg0);
    <T> @PolyThread Single<T> toSingleDefault(@PolyThread Completable this, T arg0);
    //    Completable unsubscribeOn(Scheduler arg0);
    //    TestObserver<Void> test();
    //    TestObserver<Void> test(boolean arg0);
}
