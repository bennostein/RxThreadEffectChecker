import org.checkerframework.checker.guieffect.qual.*;
import com.ubercab.rxthreadchecker.qual.*;

package io.reactivex;

class Maybe<T> implements MaybeSource<T> {
    //    Maybe();
    //    static <T> Maybe<T> amb(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Maybe<T> ambArray(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> concat(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> concat(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1);
    //    static <T> Flowable<T> concat(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2);
    //    static <T> Flowable<T> concat(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2, MaybeSource<? extends T> arg3);
    //    static <T> Flowable<T> concat(Publisher<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> concat(Publisher<? extends MaybeSource<? extends T>> arg0, int arg1);
    //    static <T> Flowable<T> concatArray(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> concatArrayDelayError(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> concatArrayEager(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> concatDelayError(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> concatDelayError(Publisher<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> concatEager(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> concatEager(Publisher<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Maybe<T> create(MaybeOnSubscribe<T> arg0);
    //    static <T> Maybe<T> defer(Callable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Maybe<T> empty();
    //    static <T> Maybe<T> error(Throwable arg0);
    //    static <T> Maybe<T> error(Callable<? extends Throwable> arg0);
    //    static <T> Maybe<T> fromAction(Action arg0);
    //    static <T> Maybe<T> fromCompletable(CompletableSource arg0);
    //    static <T> Maybe<T> fromSingle(SingleSource<T> arg0);
    //    static <T> Maybe<T> fromCallable(Callable<? extends T> arg0);
    //    static <T> Maybe<T> fromFuture(Future<? extends T> arg0);
    //    static <T> Maybe<T> fromFuture(Future<? extends T> arg0, long arg1, TimeUnit arg2);
    //    static <T> Maybe<T> fromRunnable(Runnable arg0);
    //    static <T> Maybe<T> just(T arg0);
    //    static <T> Flowable<T> merge(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> merge(Publisher<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> merge(Publisher<? extends MaybeSource<? extends T>> arg0, int arg1);
    //    static <T> Maybe<T> merge(MaybeSource<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> merge(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1);
    //    static <T> Flowable<T> merge(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2);
    //    static <T> Flowable<T> merge(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2, MaybeSource<? extends T> arg3);
    //    static <T> Flowable<T> mergeArray(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> mergeArrayDelayError(MaybeSource<? extends T>[] arg0);
    //    static <T> Flowable<T> mergeDelayError(Iterable<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> mergeDelayError(Publisher<? extends MaybeSource<? extends T>> arg0);
    //    static <T> Flowable<T> mergeDelayError(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1);
    //    static <T> Flowable<T> mergeDelayError(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2);
    //    static <T> Flowable<T> mergeDelayError(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, MaybeSource<? extends T> arg2, MaybeSource<? extends T> arg3);
    //    static <T> Maybe<T> never();
    //    static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1);
    //    static <T> Single<Boolean> sequenceEqual(MaybeSource<? extends T> arg0, MaybeSource<? extends T> arg1, BiPredicate<? super T,? super T> arg2);
    //    static Maybe<Long> timer(long arg0, TimeUnit arg1);
    //    static Maybe<Long> timer(long arg0, TimeUnit arg1, Scheduler arg2);
    //    static <T> Maybe<T> unsafeCreate(MaybeSource<T> arg0);
    //    static <T, D> Maybe<T> using(Callable<? extends D> arg0, Function<? super D,? extends MaybeSource<? extends T>> arg1, Consumer<? super D> arg2);
    //    static <T, D> Maybe<T> using(Callable<? extends D> arg0, Function<? super D,? extends MaybeSource<? extends T>> arg1, Consumer<? super D> arg2, boolean arg3);
    //    static <T> Maybe<T> wrap(MaybeSource<T> arg0);
    //    static <T, R> Maybe<R> zip(Iterable<? extends MaybeSource<? extends T>> arg0, Function<? super Object[],? extends R> arg1);
    //    static <T1, T2, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, BiFunction<? super T1,? super T2,? extends R> arg2);
    //    static <T1, T2, T3, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, Function3<? super T1,? super T2,? super T3,? extends R> arg3);
    //    static <T1, T2, T3, T4, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, Function4<? super T1,? super T2,? super T3,? super T4,? extends R> arg4);
    //    static <T1, T2, T3, T4, T5, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, MaybeSource<? extends T5> arg4, Function5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R> arg5);
    //    static <T1, T2, T3, T4, T5, T6, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, MaybeSource<? extends T5> arg4, MaybeSource<? extends T6> arg5, Function6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R> arg6);
    //    static <T1, T2, T3, T4, T5, T6, T7, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, MaybeSource<? extends T5> arg4, MaybeSource<? extends T6> arg5, MaybeSource<? extends T7> arg6, Function7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R> arg7);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, MaybeSource<? extends T5> arg4, MaybeSource<? extends T6> arg5, MaybeSource<? extends T7> arg6, MaybeSource<? extends T8> arg7, Function8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R> arg8);
    //    static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Maybe<R> zip(MaybeSource<? extends T1> arg0, MaybeSource<? extends T2> arg1, MaybeSource<? extends T3> arg2, MaybeSource<? extends T4> arg3, MaybeSource<? extends T5> arg4, MaybeSource<? extends T6> arg5, MaybeSource<? extends T7> arg6, MaybeSource<? extends T8> arg7, MaybeSource<? extends T9> arg8, Function9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R> arg9);
    //    static <T, R> Maybe<R> zipArray(Function<? super Object[],? extends R> arg0, MaybeSource<? extends T>[] arg1);
    @PolyThread Maybe<T> ambWith(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    <R> @PolyThread R as(@PolyThread Maybe<T> this, MaybeConverter<T, ? extends R> converter);
    //    T blockingGet();
    //    T blockingGet(T arg0);
    //    Maybe<T> cache();
    <U> @PolyThread Maybe<U> cast(@PolyThread Maybe<T> this, Class<? extends U> arg0);
    <R> @PolyThread Maybe<R> compose(@PolyThread Maybe<T> this, MaybeTransformer<? super T,? extends R> arg0);
    <R> @PolyThread Maybe<R> concatMap(@PolyThread Maybe<T> this, Function<? super T,? extends MaybeSource<? extends R>> arg0);
    @PolyThread Flowable<T> concatWith(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    @PolyThread Single<Boolean> contains(@PolyThread Maybe<T> this, Object arg0);
    @PolyThread Single<Long> count(@PolyThread Maybe<T> this);
    @PolyThread Maybe<T> defaultIfEmpty(@PolyThread Maybe<T> this, T arg0);
    @AnyThread Maybe<T> delay(@AnyThread Maybe<T> this, long arg0, TimeUnit arg1);
    @AnyThread Maybe<T> delay(@AnyThread Maybe<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <U, V> @AnyThread Maybe<T> delay(@AnyThread Maybe<T> this, Publisher<U> arg0);
    <U> @PolyThread Maybe<T> delaySubscription(@PolyThread Maybe<T> this, Publisher<U> arg0);
    @PolyThread Maybe<T> delaySubscription(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1);
    @PolyThread Maybe<T> delaySubscription(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doAfterSuccess(@PolyThread Maybe<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doAfterTerminate(@PolyThread Maybe<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doFinally(@PolyThread Maybe<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnDispose(@PolyThread Maybe<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnComplete(@PolyThread Maybe<T> this, @UI Action arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnError(@PolyThread Maybe<T> this, @UI Consumer<? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnEvent(@PolyThread Maybe<T> this, @UI BiConsumer<? super T,? super Throwable> arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnSubscribe(@PolyThread Maybe<T> this, @UI Consumer<? super Disposable> arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> doOnSuccess(@PolyThread Maybe<T> this, @UI Consumer<? super T> arg0);
    @SubscribeEffects({0}) @PolyThread Maybe<T> filter(@PolyThread Maybe<T> this, @PolyUI Predicate<? super T> arg0);
    <R> @AnyThread Maybe<R> flatMap(@AnyThread Maybe<T> this, Function<? super T,? extends MaybeSource<? extends R>> arg0);
    <R> @AnyThread Maybe<R> flatMap(@AnyThread Maybe<T> this, Function<? super T,? extends MaybeSource<? extends R>> arg0, Function<? super Throwable,? extends MaybeSource<? extends R>> arg1, Callable<? extends MaybeSource<? extends R>> arg2);
    <U, R> @AnyThread Maybe<R> flatMap(@AnyThread Maybe<T> this, Function<? super T,? extends MaybeSource<? extends U>> arg0, BiFunction<? super T,? super U,? extends R> arg1);
    <U> @PolyThread Flowable<U> flattenAsFlowable(@PolyThread Maybe<T> this, Function<? super T,? extends Iterable<? extends U>> arg0);
    <U> @PolyThread Observable<U> flattenAsObservable(@PolyThread Maybe<T> this, Function<? super T,? extends Iterable<? extends U>> arg0);
    <R> @AnyThread Observable<R> flatMapObservable(@AnyThread Maybe<T> this, Function<? super T,? extends ObservableSource<? extends R>> arg0);
    <R> @AnyThread Flowable<R> flatMapPublisher(@AnyThread Maybe<T> this, Function<? super T,? extends Publisher<? extends R>> arg0);
    <R> @AnyThread Single<R> flatMapSingle(@AnyThread Maybe<T> this, Function<? super T,? extends SingleSource<? extends R>> arg0);
    <R> @AnyThread Maybe<R> flatMapSingleElement(@AnyThread Maybe<T> this, Function<? super T,? extends SingleSource<? extends R>> arg0);
    Completable flatMapCompletable(@AnyThread Maybe<T> this, Function<? super T,? extends CompletableSource> arg0);
    @PolyThread Maybe<T> hide(@PolyThread Maybe<T> this);
    //    Completable ignoreElement();
    @PolyThread Single<Boolean> isEmpty(@PolyThread Maybe<T> this);
    <R> @PolyThread Maybe<R> lift(@PolyThread Maybe<T> this, MaybeOperator<? extends R,? super T> arg0);
    <R> @PolyThread Maybe<R> map(@PolyThread Maybe<T> this, Function<? super T,? extends R> arg0);
    @PolyThread Flowable<T> mergeWith(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    @PolyThread Maybe<T> observeOn(@PolyThread Scheduler arg0);
    <U> @PolyThread Maybe<U> ofType(@PolyThread Maybe<T> this, Class<U> arg0);
    <R> @PolyThread R to(@PolyThread Maybe<T> this, Function<? super Maybe<T>,R> arg0);
    @PolyThread Flowable<T> toFlowable(@PolyThread Maybe<T> this);
    @PolyThread Observable<T> toObservable(@PolyThread Maybe<T> this);
    @PolyThread Single<T> toSingle(@PolyThread Maybe<T> this, T arg0);
    @PolyThread Single<T> toSingle(@PolyThread Maybe<T> this);
    @PolyThread Maybe<T> onErrorComplete(@PolyThread Maybe<T> this);
    @PolyThread Maybe<T> onErrorComplete(@PolyThread Maybe<T> this, Predicate<? super Throwable> arg0);
    @PolyThread Maybe<T> onErrorResumeNext(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    @PolyThread Maybe<T> onErrorResumeNext(@PolyThread Maybe<T> this, Function<? super Throwable,? extends MaybeSource<? extends T>> arg0);
    @PolyThread Maybe<T> onErrorReturn(@PolyThread Maybe<T> this, Function<? super Throwable,? extends T> arg0);
    @PolyThread Maybe<T> onErrorReturnItem(@PolyThread Maybe<T> this, T arg0);
    @PolyThread Maybe<T> onExceptionResumeNext(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    @PolyThread Maybe<T> onTerminateDetach(@PolyThread Maybe<T> this);
    @PolyThread Flowable<T> repeat(@PolyThread Maybe<T> this);
    @PolyThread Flowable<T> repeat(@PolyThread Maybe<T> this, long arg0);
    @PolyThread Flowable<T> repeatUntil(@PolyThread Maybe<T> this, BooleanSupplier arg0);
    @PolyThread Flowable<T> repeatWhen(@PolyThread Maybe<T> this, Function<? super Flowable<Object>,? extends Publisher<?>> arg0);
    @PolyThread Maybe<T> retry(@PolyThread Maybe<T> this);
    @PolyThread Maybe<T> retry(@PolyThread Maybe<T> this, BiPredicate<? super Integer,? super Throwable> arg0);
    @PolyThread Maybe<T> retry(@PolyThread Maybe<T> this, long arg0);
    @PolyThread Maybe<T> retry(@PolyThread Maybe<T> this, long arg0, Predicate<? super Throwable> arg1);
    @PolyThread Maybe<T> retry(@PolyThread Maybe<T> this, Predicate<? super Throwable> arg0);
    @PolyThread Maybe<T> retryUntil(@PolyThread Maybe<T> this, BooleanSupplier arg0);
    @PolyThread Maybe<T> retryWhen(@PolyThread Maybe<T> this, Function<? super Flowable<Throwable>,? extends Publisher<?>> arg0);
    //    Disposable subscribe();
    @SubscribeEffects({0}) Disposable subscribe(@UI Consumer<? super T> arg0);
    @SubscribeEffects({0,1}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1);
    @SubscribeEffects({0,1,2}) Disposable subscribe(@UI Consumer<? super T> arg0, @UI Consumer<? super Throwable> arg1, @UI Action arg2);
    @SubscribeEffects({0}) void subscribe(@UI MaybeObserver<? super T> arg0);
    //    protected void subscribeActual(MaybeObserver<? super T> arg0);
    //    Maybe<T> subscribeOn(Scheduler arg0);
    @SubscribeEffects({0}) <E> E subscribeWith(@UI E arg0);
    @PolyThread Maybe<T> switchIfEmpty(@PolyThread Maybe<T> this, MaybeSource<? extends T> arg0);
    <U> @PolyThread Maybe<T> takeUntil(@PolyThread Maybe<T> this, MaybeSource<U> arg0);
    <U> @PolyThread Maybe<T> takeUntil(@PolyThread Maybe<T> this, Publisher<U> arg0);
    @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1);
    @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1, MaybeSource<? extends T> arg2);
    @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1, Scheduler arg2, MaybeSource<? extends T> arg3);
    @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, long arg0, TimeUnit arg1, Scheduler arg2);
    <U> @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, MaybeSource<U> arg0);
    <U> @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, MaybeSource<U> arg0, MaybeSource<? extends T> arg1);
    <U> @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, Publisher<U> arg0);
    <U> @PolyThread Maybe<T> timeout(@PolyThread Maybe<T> this, Publisher<U> arg0, MaybeSource<? extends T> arg1);
    //    Maybe<T> unsubscribeOn(Scheduler arg0);
    <U, R> @PolyThread Maybe<R> zipWith(@PolyThread Maybe<T> this, MaybeSource<? extends U> arg0, BiFunction<? super T,? super U,? extends R> arg1);
    //    TestObserver<T> test();
    //    TestObserver<T> test(boolean arg0);
}
